$CFLAGS = "-g -O -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DALL_INTERIOR_POINTERS "
    . "-DNO_EXECUTE_PERMISSION -DSILENT -DLARGE_CONFIG";



&emit_c_file_rule('allchblk', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h');
&emit_c_file_rule('alloc', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h',
		  'version.h');
&emit_c_file_rule('blacklst', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h');
&emit_c_file_rule('checksums', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h');
&emit_c_file_rule('dbg_mlc', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h');

&emit_c_file_rule('dyn_load', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h');

&emit_c_file_rule('finalize', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h',
		  'gc_mark.h');
&emit_c_file_rule('headers', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h');
&emit_c_file_rule('hpux_irix_threads', 'gc.h', 'gc_priv.h', 'gcconfig.h',
		  'gc_hdrs.h');
&emit_c_file_rule('linux_threads', 'gc.h', 'gc_priv.h', 'gcconfig.h',
		  'gc_hdrs.h');

# FIXME
if ($target_name =~ /^sparc.*-solaris/) {
    &emit_asm_file_rule('mach_dep', 'sparc_mach_dep');
} elsif ($target_name =~ /^sparc.*-openbsd/) {
    &emit_asm_file_rule('mach_dep', 'sparc_sunos4_mach_dep');
} elsif ($target_name =~ /^sparc.*-sunos4/) {
    &emit_asm_file_rule('mach_dep', 'sparc_sunos4_mach_dep');
} elsif ($target_name =~ /^alpha/) {
    &emit_cppasm_file_rule('mach_dep', 'alpha_mach_dep');
} elsif ($target_name =~ /^mips-irix/) {
    &emit_asm_file_rule('mach_dep', 'mips_sgi_mach_dep');
} elsif ($target_name =~ /^mips-riscos/) {
    &emit_asm_file_rule('mach_dep', 'mips_ultrix_mach_dep');
} elsif ($target_name =~ /^mips-ultrix/) {
    &emit_asm_file_rule('mach_dep', 'mips_ultrix_mach_dep');
} elsif ($target_name =~ /rs6000/) {
    &emit_asm_file_rule('mach_dep', 'rs6000_mach_dep');
} else {
    local ($CFLAGS) = "-g";
    &emit_c_file_rule('mach_dep', 'gc.h', 'gc_priv.h', 'gcconfig.h',
		      'gc_hdrs.h');
}

&emit_c_file_rule('malloc', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h');
&emit_c_file_rule('mallocx', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h');
&emit_c_file_rule('mark', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h',
		  'gc_mark.h');
if ($target_name =~ /^alpha/) {
    local ($CFLAGS) = "$CFLAGS -Wo,-notail";
    &emit_c_file_rule('mark_rts', 'gc.h', 'gc_priv.h', 'gcconfig.h',
		      'gc_hdrs.h');
} else {
    &emit_c_file_rule('mark_rts', 'gc.h', 'gc_priv.h', 'gcconfig.h',
		      'gc_hdrs.h');
}

&emit_c_file_rule('misc', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h');
&emit_c_file_rule('new_hblk', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h');
&emit_c_file_rule('obj_map', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h');
&emit_c_file_rule('os_dep', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h');
&emit_c_file_rule('ptr_chck', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h',
		  'gc_mark.h');
&emit_c_file_rule('reclaim', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h');
&emit_c_file_rule('solaris_pthreads', 'gc.h', 'gc_priv.h', 'gcconfig.h',
		  'gc_hdrs.h', 'solaris_threads.h');
&emit_c_file_rule('solaris_threads', 'gc.h', 'gc_priv.h', 'gcconfig.h',
		  'gc_hdrs.h', 'solaris_threads.c');
&emit_c_file_rule('stubborn', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h');
&emit_c_file_rule('typd_mlc', 'gc.h', 'gc_priv.h', 'gcconfig.h', 'gc_hdrs.h',
		  'gc_mark.h', 'gc_typed.h');

$lib_name = "$lib_prefix" . "gc$dot_lib";

$objs =
    "allchblk$dot_obj"
    . " alloc$dot_obj"
    . " blacklst$dot_obj"
    . " checksums$dot_obj"
    . " dbg_mlc$dot_obj"
    . " dyn_load$dot_obj"
    . " finalize$dot_obj"
    . " headers$dot_obj"
    . " hpux_irix_threads$dot_obj"
    . " linux_threads$dot_obj"
    . " mach_dep$dot_obj"
    . " malloc$dot_obj"
    . " mallocx$dot_obj"
    . " mark$dot_obj"
    . " mark_rts$dot_obj"
    . " misc$dot_obj"
    . " new_hblk$dot_obj"
    . " obj_map$dot_obj"
    . " os_dep$dot_obj"
    . " ptr_chck$dot_obj"
    . " reclaim$dot_obj"
    . " solaris_pthreads$dot_obj"
    . " solaris_threads$dot_obj"
    . " stubborn$dot_obj"
    . " typd_mlc$dot_obj";

print "$lib_name: $objs\n";
print "\trm -f $lib_name\n\t";

if($target_name =~ /^ppc/) {
    $target_platform{'link_shared_library_command'} = $target_platform{'link_shared_library_command'} . " -static";
}

if ($shared) {
    printf($target_platform{'link_shared_library_command'}, $lib_name,
     $objs, $libdir);
    print "\n";
    if ($static) {
	local ($dot_lib)
	    = split(/\s+/, $target_platform{'library_filename_suffix'});
	local ($unit_prefix) = "gc";
	print "\trm -f $lib_prefix$unit_prefix$dot_lib\n";
	print "\tln -s .libs/$lib_prefix$unit_prefix$dot_lib",
	" $lib_prefix$unit_prefix$dot_lib\n";
    }
} else {
    printf($target_platform{'link_library_command'}, $lib_name, $objs);
    print "\n";
    if($target_platform{'randomize_library_command'}) {
	print "\t";
        printf($target_platform{'randomize_library_command'}, $lib_name);
        print "\n";
    }
}

push(@compile_dependencies, $lib_name);
do install_library($libdir, $lib_name, $shared);
push(@files_to_clean, $lib_name);
