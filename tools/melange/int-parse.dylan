documented: #t
module: int-parse
author:  Robert Stockton (rgs@cs.cmu.edu)
copyright: Copyright (C) 1994, Carnegie Mellon University
	   All rights reserved.
	   This code was produced by the Gwydion Project at Carnegie Mellon
	   University.  If you are interested in using this code, contact
	   "Scott.Fahlman@cs.cmu.edu" (Internet).
rcs-header: $Header: 

//======================================================================
//
// Copyright (c) 1994  Carnegie Mellon University
// All rights reserved.
//
//======================================================================

//======================================================================
// Module int-parse handles parsing of define interface forms in interace
// files.  It makes no attempt to handle any other part of the Dylan language
// at this time, since it will eventually be merged into the native parser for
// the Gwydion compiler.
//
// The actual "source" for this parser is contained in "int-parse.input",
// which is an input file for a lisp-based Dylan parser generator.  (This is a
// logical route to follow for bootstrapping purposes.  It would clearly be
// useful to re-implement the generator in Dylan at some future date.)
// "Int-parse.dylan" is the pure Dylan output of this generator, and should
// *not* be considered human readable code.
//
// The "parse-tree" is a very ad-hoc structure, because it is intended to be
// quite ephemeral.  The final goal is to add annotations to the "parse-state"
// which describe the C header file to be processed and the transformations to
// apply to that header file's declarations.
//
// The external interface to the parser is the function "parse", which has the
// following interface:
//   parse(parse-state, #key defines, undefines) => ()
//     This function processes a single "define interface" form, using the
//     tokenizer in "parse-state", and annotates the parse state with the
//     information acquired.
// <parse-state> is defined below, and contains both global modifiers such as
// "include file" or "object file" and "clauses" which describe the processing
// of a single object.
//
//======================================================================

//----------------------------------------------------------------------
// Simple parser support 
//----------------------------------------------------------------------

// Designates an "optional" string.
//
define constant <string?> = type-union(<string>, <false>);

// Undefined values are useful for values that may need to be defaulted.  This
// is superious do simply filling in the default value at the start, since it
// allows us to merge several <container-option>s before doing the defaulting.
//
define class <undefined> (<object>) end class;
define constant undefined = make(<undefined>);

// Container options can either describe global modifications to be applied to
// all objects or can describe a set of modifications for some single object.
// Each of the fields corresponds pretty closely to a single "container
// option" in the Creole/Melange specs.
//
define class <container-options> (<object>)
  slot name-mapper :: type-union(<symbol>, <undefined>), init-value: undefined;
  // each element of imports is either #"all" or an import list
  slot global-import-mode
    :: one-of(#"all", #"all-recursive", #"none", #"undecided") = #"undecided";
  slot global-imports :: <sequence> = make(<stretchy-vector>);
  slot file-import-modes = make(<string-table>) /* of #"all", #"none" */;
  slot file-imports = make(<string-table>) /* of <sequence> */;
  slot prefix :: type-union(<string>, <undefined>), init-value: undefined;
  constant slot exclude = make(<deque>);
  constant slot excluded-files = make(<deque>);
  slot rename :: <sequence>, init-value: #();
  slot mappings :: <sequence>, init-value: #();
  slot equates :: <sequence>, init-value: #();
  slot read-only :: type-union(<boolean>, <undefined>), init-value: undefined;
  slot seal-string :: type-union(<string>, <undefined>), init-value: undefined;
end class <container-options>;

// This structure contains the tokenizer which defines the input to the
// parser, and also contains slot which will be filled in based upon the
// results of the parse.  It includes slots for various options which are
// unique to "#include" clauses, a <container-options> slot which corresponds
// to container options that have been globally applied in the "#include"
// clause, and a sequence of "<clause>"s (defined below) in no particular
// order. 
//
define class <parse-state> (<object>)
  slot tokenizer :: <tokenizer>, required-init-keyword: #"tokenizer";
  slot include-files :: false-or(<sequence>) = #f;
  slot object-files :: <deque>, init-function: curry(make, <deque>);
  slot mindy-include-file :: <string?>, init-value: #f;
  slot macro-defines :: <deque>, init-function: curry(make, <deque>);
  slot macro-undefines :: <deque>, init-function: curry(make, <deque>);
  slot container-options :: <container-options>;
  slot clauses :: <sequence>, init-value: #();
end class <parse-state>;

// This function fills in slots of a <container-option> based upon the raw
// "parse-tree" returned by some production.  This stuff is very ad-hoc, since
// there is little use in carefully defining the structure of an object that
// will last for milliseconds or less.
//
define method process-container-options 
    (parsed-clauses :: <list>)
 => (result :: <container-options>, rest :: <list>);
  let result = make(<container-options>);
  let left = #();
  for (item in parsed-clauses)
    select (item.first)
      #"name-mapper" =>
        if (result.name-mapper ~= undefined)
          error("Multiple name mappers in one #include clause");
        else
          result.name-mapper := item.second;
        end if;
      #"import" =>
	let value = item.second;
        if (instance?(value, <sequence>))
          for (import in value)
            add!(result.global-imports, import);
          end for;
	  if (result.global-import-mode == #"undecided")
            result.global-import-mode := #"none";
          end if;
        else
          result.global-import-mode := value;
        end if;
      #"import-file" =>
        let (file, stream) = open-in-include-path(item.second.value);
        if (stream)
          close(stream);
        else
          parse-error(item.second, "File does not exist in path.");
        end if;
	let value = item.third;
        if (instance?(value, <sequence>))
	  let imports = (element(result.file-imports, file, default: #f)
                          | (result.file-imports[file]
			       := make(<stretchy-vector>)));
	  for (import in value)
	    add!(imports, import);
          end for;
	  unless (element(result.file-import-modes, file, default: #f))
            result.file-import-modes[file] := #"none";
          end unless;
        else
          result.file-import-modes[file] := value;
        end if;
      #"prefix" =>
        if (result.prefix ~= undefined)
          error("Multiple prefixes in one #include clause");
        else
          result.prefix := item.second;
        end if;
      #"exclude" =>
        // exclude lists contain tokens
 	for (elem in item.second) add!(result.exclude, elem.value) end for;
      #"exclude-file" =>
        // exclude lists contain tokens
	for (elem in item.second) 
          let (file, stream) = open-in-include-path(elem.value);
          if (stream)
	    add!(result.excluded-files, file);
            close(stream);
          else
            parse-error(elem, "File does not exist in path.");
          end if;
        end for;
      #"rename" =>
        result.rename := reduce(method(a,b) pair(b,a) end method,
                                result.rename, item.second);
      #"mapping" =>
        result.mappings := reduce(method(a,b) pair(b,a) end method,
                                  result.mappings, item.second);
      #"equate" =>
        result.equates := reduce(method(a,b) pair(b,a) end method,
                      	         result.equates, item.second);
      #"read-only" =>
        result.read-only := item.second;
      #"seal" =>
        result.seal-string := item.second;
      otherwise =>
        left := pair(item, left);
    end select;
  end for;
  values(result, reverse!(left));
end method process-container-options;

// This corresponds to any "clause" in the interface definition which is not a
// "#include".  Most of them are simply typed "boxes" for sequences of
// "options".  At present the options consist of a sequence labelled by an
// initial symbol.  At some later time they may be fleshed out in more detail.
// Some clauses also contain a <container-options> structure which breaks down
// some of the options in a more convenient format.
//
define class <clause> (<object>) 
  slot name :: <string>, required-init-keyword: #"name";
  slot options :: <sequence>, required-init-keyword: #"options";
end class;

define class <function-clause> (<clause>) end class;
define class <variable-clause> (<clause>) end class;
define class <constant-clause> (<clause>) end class;
define class <pointer-clause> (<clause>) end class;

define class <container-clause> (<clause>)
  slot container-options :: <container-options>;
end class <container-clause>;

define class <struct-clause> (<container-clause>) end class;
define class <union-clause> (<container-clause>) end class;


define constant <source-location> = false-or(<parse-state>);

//----------------------------------------------------------------------
// The actual productions.  The format is
//  production (sub-production-or-<token> .....)
//    Arbitrary dylan code -- variables %1 - %n correspond to the
//    sub-productions, and @0 is a <parse-state> which is passed into each
//    action routine for record-keeping purposes.
//  %
//----------------------------------------------------------------------

define constant $action-bits = 2;
define constant $action-mask = ash(1, $action-bits) - 1;

define constant $error-action = 0;
define constant $accept-action = 1;
define constant $reduce-action = 2;
define constant $shift-action = 3;

define constant $action-table
  = #[#[0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 399, 0, 0, 0, 0, 0, 0, 0, 0, 539, 603, 627, 659, 699, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 367, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 58, 58, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 27, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 39, 47, 91, 123, 131, 211, 219, 247, 267, 299, 315, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 351, 0, 331, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66, 66, 0, 0, 0],
      #[0, 0, 0, 0, 43, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 70, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 70, 70, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51, 0, 0],
      #[0, 0, 0, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 94, 0, 94, 59],
      #[0, 0, 67, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 98, 0, 98, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 102, 0, 102, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 0, 86, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79, 0, 87, 0],
      #[0, 0, 0, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 90, 0, 90, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 74, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 74, 74, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0],
      #[0, 0, 0, 0, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 114, 0, 114, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106, 0, 106, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 0, 119, 0],
      #[0, 0, 0, 0, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110, 0, 110, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 78, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118, 118, 0, 0, 0],
      #[0, 0, 0, 0, 183, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135, 0, 139, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 143, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 122, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 122, 122, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 126, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 126, 126, 0, 0, 0],
      #[0, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 146, 0, 146, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 158, 0, 158, 151],
      #[0, 0, 0, 0, 0, 0, 0, 0, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 166, 0, 166, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 162, 0, 162, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 154, 0, 154, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 171, 0, 179, 0],
      #[0, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 150, 0, 150, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 130, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 130, 130, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 187],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 191, 195, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 199, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 134, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 134, 134, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 138, 0, 0, 0],
      #[0, 0, 0, 0, 147, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 146, 0, 146, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 171, 0, 207, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 142, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 142, 142, 0, 0, 0],
      #[0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 170, 170, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 223, 0, 0],
      #[0, 0, 0, 0, 227, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 178, 0, 178, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 186, 0, 186, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235, 0, 243, 0],
      #[0, 0, 0, 0, 239, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 182, 0, 182, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 174, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 174, 174, 0, 0, 0],
      #[0, 0, 0, 0, 251, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 190, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 190, 190, 0, 0, 0],
      #[0, 0, 0, 0, 227, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 178, 0, 178, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235, 0, 263, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 194, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 194, 194, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 271, 0, 0],
      #[0, 0, 0, 0, 275, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 202, 0, 202, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 151],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 210, 0, 210, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 287, 0, 295, 0],
      #[0, 0, 0, 0, 275, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 206, 0, 206, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 198, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 198, 198, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 303, 0, 0],
      #[0, 0, 0, 0, 275, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 202, 0, 202, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 287, 0, 311, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 214, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 319, 0, 0],
      #[0, 0, 0, 0, 275, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 202, 0, 202, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 287, 0, 327, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 218, 218, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 335, 339, 343, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 222, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 222, 222, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 226, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 226, 226, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 230, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 234, 234, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 355, 355, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 238, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 238, 238, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 82, 82, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 62, 0, 0, 0],
      #[0, 0, 0, 0, 371, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 50, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 379, 0, 387, 0],
      #[0, 0, 0, 0, 383, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 54, 0, 54, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 58, 58, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 46, 27, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 0, 0, 0, 0],
      #[0, 0, 0, 0, 403, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 250, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 250, 250, 0, 0, 527],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 242, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 242, 411, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 415, 423, 431, 439, 475, 499, 515, 507, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 419, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 258, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 258, 258, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 427, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 262, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 262, 262, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 435, 435, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 266, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 266, 266, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 443, 0, 0],
      #[0, 0, 447, 0, 455, 0, 0, 0, 451, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 290, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 290, 290, 0, 0, 290],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 294, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 294, 294, 0, 0, 294],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 298, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 298, 298, 0, 0, 298],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 463],
      #[0, 0, 0, 0, 0, 0, 0, 0, 467, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 471, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 270, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 270, 270, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 479, 0, 0],
      #[0, 0, 447, 0, 455, 0, 0, 0, 451, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 487],
      #[0, 0, 0, 0, 0, 0, 0, 0, 491, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 495, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 274, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 274, 274, 0, 0, 0],
      #[0, 0, 447, 0, 455, 0, 0, 0, 451, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 278, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 278, 278, 0, 0, 0],
      #[0, 0, 447, 0, 455, 0, 0, 0, 451, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 282, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 282, 282, 0, 0, 0],
      #[0, 0, 447, 0, 455, 0, 0, 0, 451, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 286, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 286, 286, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 254, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 254, 254, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 531, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 250, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 250, 250, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 246, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 246, 411, 0, 0, 0],
      #[0, 0, 0, 0, 543, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 318, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 318, 318, 0, 0, 591],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 302, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 302, 551, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 123, 131, 211, 219, 247, 267, 299, 315, 559, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 351, 0, 331, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 322, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 322, 322, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 563, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 567, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 326, 0, 326, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 575, 0, 583, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 579, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 330, 0, 330, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 334, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 334, 334, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 338, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 338, 338, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 595, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 318, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 318, 318, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 306, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 306, 551, 0, 0, 0],
      #[0, 0, 0, 0, 607, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 318, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 318, 318, 0, 0, 615],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 310, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 310, 551, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 619, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 318, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 318, 318, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 314, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 314, 551, 0, 0, 0],
      #[0, 0, 0, 0, 631, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 350, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 350, 350, 0, 0, 647],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 639, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 559, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 354, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 354, 354, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 651, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 350, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 350, 350, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 346, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 346, 639, 0, 0, 0],
      #[0, 0, 0, 0, 663, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 366, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 366, 366, 0, 0, 687],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 358, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 358, 671, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 675, 0, 0, 0, 0, 0],
      #[0, 0, 679, 679, 679, 679, 679, 679, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 374, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 374, 374, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 370, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 370, 370, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 691, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 366, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 366, 366, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 362, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 362, 671, 0, 0, 0],
      #[0, 0, 0, 0, 703, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 386, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 386, 386, 0, 0, 763],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 378, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 378, 711, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 731, 739, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 747, 715, 723, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 719, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 398, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 398, 398, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 727, 727, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 402, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 402, 402, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 735, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 406, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 406, 406, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 743, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 410, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 410, 410, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 751, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 335, 339, 343, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 394, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 394, 394, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 414, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 414, 414, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 390, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 390, 390, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 767, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 386, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 386, 386, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 382, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 382, 711, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 783, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 399, 0, 0, 0, 0, 0, 0, 0, 0, 539, 603, 627, 659, 699, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 0, 0, 0],
      #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 795, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 799, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0],
      #[14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0],
      #[811, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 807, 0, 0, 0, 0],
      #[6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      #[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];

define method production-1
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // parse-root -> interface-def <SEMICOLON-TOKEN>
  values(203,
         begin
           // dispose of semi if it exists, but accept EOF instead
           #t;
         end);
end method production-1;

define method production-2
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <SIMPLE-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // parse-root -> interface-def EOF
  values(203,
         begin
           #t;
         end);
end method production-2;

define method production-3
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <RESERVED-WORD-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <RESERVED-WORD-TOKEN>, srcloc-4 :: <source-location>,
     rhs-5 :: <RESERVED-WORD-TOKEN>, srcloc-5 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-def -> <DEFINE-TOKEN> <INTERFACE-TOKEN> interface-clause-list <END-TOKEN> <INTERFACE-TOKEN>
  values(200,
         begin
         end);
end method production-3;

define method production-4
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <RESERVED-WORD-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <RESERVED-WORD-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-def -> <DEFINE-TOKEN> <INTERFACE-TOKEN> interface-clause-list <END-TOKEN>
  values(200,
         begin
         end);
end method production-4;

define method production-5
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-clause-list -> interface-clause-list1 <SEMICOLON-TOKEN>
  values(197,
         begin
           rhs-1;
         end);
end method production-5;

define method production-6
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-clause-list -> interface-clause-list1
  values(197,
         begin
           rhs-1;
         end);
end method production-6;

define method production-7
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-clause-list1 -> interface-clause-list1 <SEMICOLON-TOKEN> interface-clause
  values(194,
         begin
           pair(rhs-3, rhs-1)
         end);
end method production-7;

define method production-8
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-clause-list1 -> interface-clause
  values(194,
         begin
           list(rhs-1);
         end);
end method production-8;

define method production-9
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-clause -> file-clause
  values(select (prev-state)
           195 => 196;
           OTHERWISE => 193;
         end,
         begin
           rhs-1;
         end);
end method production-9;

define method production-10
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file-clause -> <INCLUDE-TOKEN> <STRING-LITERAL-TOKEN> file-option-list
  values(98,
         begin
           if (srcloc-0.include-files) 
             parse-error(rhs-1, "More than one #include in interface definition.")
           end if;
           srcloc-0.include-files := vector(rhs-2.value);
           srcloc-0.container-options := process-container-options(rhs-3);
         end);
end method production-10;

define method production-11
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>,
     rhs-5, srcloc-5 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file-clause -> <INCLUDE-TOKEN> <LBRACE-TOKEN> include-file-list <RBRACE-TOKEN> file-option-list
  values(98,
         begin
           if (srcloc-0.include-files) 
             parse-error(rhs-1, "More than one #include in interface definition.")
           end if;
           srcloc-0.include-files := as(<simple-object-vector>, rhs-3);
           srcloc-0.container-options := process-container-options(rhs-5);
         end);
end method production-11;

define method production-12
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <LITERAL-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // include-file-list -> <STRING-LITERAL-TOKEN>
  values(93,
         begin
           make(<stretchy-vector>, size: 1, fill: rhs-1.value);
         end);
end method production-12;

define method production-13
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <LITERAL-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // include-file-list -> include-file-list <COMMA-TOKEN> <STRING-LITERAL-TOKEN>
  values(93,
         begin
           add!(rhs-1, rhs-3.value);
         end);
end method production-13;

define method production-14
    (prev-state :: <integer>, srcloc-0 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file-option-list -> epsilon
  values(select (prev-state)
           96 => 97;
           OTHERWISE => 5;
         end,
         begin
           #();
         end);
end method production-14;

define method production-15
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file-option-list -> file-option-list <COMMA-TOKEN> file-option
  values(select (prev-state)
           96 => 97;
           OTHERWISE => 5;
         end,
         begin
           pair(rhs-3, rhs-1);
         end);
end method production-15;

define method production-16
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file-option -> <OBJECT-FILE-TOKEN> <STRING-LITERAL-TOKEN>
  values(90,
         begin
           push-last(srcloc-0.object-files, rhs-2.value);
           pair(#"object-file", rhs-2.value);
         end);
end method production-16;

define method production-17
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file-option -> <MINDY-INC-TOKEN> <STRING-LITERAL-TOKEN>
  values(90,
         begin
           if (srcloc-0.mindy-include-file) 
             parse-error(rhs-1,
                         "More than one mindy-include-file: in interface definition.")
           end if;
           pair(#"mindy-file", srcloc-0.mindy-include-file := rhs-2.value);
         end);
end method production-17;

define method production-18
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file-option -> <DEFINE-MACRO-TOKEN> <LBRACE-TOKEN> macro-definitions <RBRACE-TOKEN>
  values(90,
         begin
           pair(#"macro-definitions", rhs-3);
         end);
end method production-18;

define method production-19
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file-option -> <UNDEFINE-TOKEN> <LBRACE-TOKEN> macro-undefinitions <RBRACE-TOKEN>
  values(90,
         begin
           pair(#"macro-undefines", rhs-3);
         end);
end method production-19;

define method production-20
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // file-option -> container-option
  values(90,
         begin
           rhs-1;
         end);
end method production-20;

define method production-21
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // macro-definitions -> macro-definition
  values(18,
         begin
           list(rhs-1);
         end);
end method production-21;

define method production-22
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // macro-definitions -> macro-definitions <COMMA-TOKEN> macro-definition
  values(18,
         begin
           pair(rhs-3, rhs-1);
         end);
end method production-22;

define method production-23
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <LITERAL-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // macro-definition -> <STRING-LITERAL-TOKEN>
  values(select (prev-state)
           19 => 20;
           OTHERWISE => 17;
         end,
         begin
           push-last(srcloc-0.macro-defines, pair(rhs-1.value, 1));
         end);
end method production-23;

define method production-24
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <LITERAL-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <LITERAL-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // macro-definition -> <STRING-LITERAL-TOKEN> <ARROW-TOKEN> <STRING-LITERAL-TOKEN>
  values(select (prev-state)
           19 => 20;
           OTHERWISE => 17;
         end,
         begin
           push-last(srcloc-0.macro-defines, pair(rhs-1.value, rhs-3.value));
         end);
end method production-24;

define method production-25
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <LITERAL-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <LITERAL-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // macro-definition -> <STRING-LITERAL-TOKEN> <ARROW-TOKEN> <INTEGER-TOKEN>
  values(select (prev-state)
           19 => 20;
           OTHERWISE => 17;
         end,
         begin
           push-last(srcloc-0.macro-defines, pair(rhs-1.value, rhs-3.value));
         end);
end method production-25;

define method production-26
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // macro-undefinitions -> macro-undefinition
  values(26,
         begin
           list(rhs-1);
         end);
end method production-26;

define method production-27
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // macro-undefinitions -> macro-undefinitions <COMMA-TOKEN> macro-undefinition
  values(26,
         begin
           pair(rhs-3, rhs-1);
         end);
end method production-27;

define method production-28
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <LITERAL-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // macro-undefinition -> <STRING-LITERAL-TOKEN>
  values(select (prev-state)
           27 => 28;
           OTHERWISE => 25;
         end,
         begin
           push-last(srcloc-0.macro-undefines, rhs-1.value);
         end);
end method production-28;

define method production-29
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <NAME-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // container-option -> <NAME-MAPPER-TOKEN> <IDENTIFIER-TOKEN>
  values(select (prev-state)
           137 => 138;
           OTHERWISE => 89;
         end,
         begin
           list(#"name-mapper", rhs-2.value);
         end);
end method production-29;

define method production-30
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <RESERVED-WORD-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // container-option -> <IMPORT-TOKEN> <ALL-TOKEN>
  values(select (prev-state)
           137 => 138;
           OTHERWISE => 89;
         end,
         begin
           list(#"import", #"all");
         end);
end method production-30;

define method production-31
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <RESERVED-WORD-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // container-option -> <IMPORT-TOKEN> <ALL-RECURSIVE-TOKEN>
  values(select (prev-state)
           137 => 138;
           OTHERWISE => 89;
         end,
         begin
           list(#"import", #"all-recursive");
         end);
end method production-31;

define method production-32
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // container-option -> <IMPORT-TOKEN> <LBRACE-TOKEN> import-list <RBRACE-TOKEN>
  values(select (prev-state)
           137 => 138;
           OTHERWISE => 89;
         end,
         begin
           list(#"import", rhs-3);
         end);
end method production-32;

define method production-33
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4 :: <RESERVED-WORD-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // container-option -> <IMPORT-TOKEN> <STRING-LITERAL-TOKEN> <ARROW-TOKEN> <ALL-TOKEN>
  values(select (prev-state)
           137 => 138;
           OTHERWISE => 89;
         end,
         begin
           list(#"import-file", rhs-2, #"all");
         end);
end method production-33;

define method production-34
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4 :: <RESERVED-WORD-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // container-option -> <IMPORT-TOKEN> <STRING-LITERAL-TOKEN> <ARROW-TOKEN> <NONE-TOKEN>
  values(select (prev-state)
           137 => 138;
           OTHERWISE => 89;
         end,
         begin
           list(#"import-file", rhs-2, #"none");
         end);
end method production-34;

define method production-35
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>,
     rhs-5, srcloc-5 :: <source-location>,
     rhs-6 :: <PUNCTUATION-TOKEN>, srcloc-6 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // container-option -> <IMPORT-TOKEN> <STRING-LITERAL-TOKEN> <ARROW-TOKEN> <LBRACE-TOKEN> import-list <RBRACE-TOKEN>
  values(select (prev-state)
           137 => 138;
           OTHERWISE => 89;
         end,
         begin
           list(#"import-file", rhs-2, rhs-5);
         end);
end method production-35;

define method production-36
    (prev-state :: <integer>, srcloc-0 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // import-list -> epsilon
  values(select (prev-state)
           49 => 50;
           OTHERWISE => 41;
         end,
         begin
           #();
         end);
end method production-36;

define method production-37
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // import-list -> import-list <COMMA-TOKEN> import
  values(select (prev-state)
           49 => 50;
           OTHERWISE => 41;
         end,
         begin
           pair(rhs-3, rhs-1);
         end);
end method production-37;

define method production-38
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // import-list -> import
  values(select (prev-state)
           49 => 50;
           OTHERWISE => 41;
         end,
         begin
           list(rhs-1);
         end);
end method production-38;

define method production-39
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <LITERAL-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // import -> <STRING-LITERAL-TOKEN>
  values(select (prev-state)
           42 => 43;
           OTHERWISE => 40;
         end,
         begin
           rhs-1.value;
         end);
end method production-39;

define method production-40
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // import -> renaming
  values(select (prev-state)
           42 => 43;
           OTHERWISE => 40;
         end,
         begin
           rhs-1;
         end);
end method production-40;

define method production-41
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <LITERAL-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <NAME-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // renaming -> <STRING-LITERAL-TOKEN> <ARROW-TOKEN> <IDENTIFIER-TOKEN>
  values(select (prev-state)
           79 => 69;
           75 => 69;
           71 => 72;
           67 => 69;
           OTHERWISE => 39;
         end,
         begin
           pair(rhs-1.value, rhs-3.value);
         end);
end method production-41;

define method production-42
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // container-option -> <PREFIX-TOKEN> <STRING-LITERAL-TOKEN>
  values(select (prev-state)
           137 => 138;
           OTHERWISE => 89;
         end,
         begin
           list(#"prefix", rhs-2.value);
         end);
end method production-42;

define method production-43
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // container-option -> <EXCLUDE-TOKEN> <LBRACE-TOKEN> exclude-list <RBRACE-TOKEN>
  values(select (prev-state)
           137 => 138;
           OTHERWISE => 89;
         end,
         begin
           list(#"exclude", rhs-3);
         end);
end method production-43;

define method production-44
    (prev-state :: <integer>, srcloc-0 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // exclude-list -> epsilon
  values(select (prev-state)
           63 => 64;
           OTHERWISE => 57;
         end,
         begin
           #();
         end);
end method production-44;

define method production-45
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <LITERAL-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // exclude-list -> exclude-list <COMMA-TOKEN> <STRING-LITERAL-TOKEN>
  values(select (prev-state)
           63 => 64;
           OTHERWISE => 57;
         end,
         begin
           pair(rhs-3, rhs-1);
         end);
end method production-45;

define method production-46
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <LITERAL-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // exclude-list -> <STRING-LITERAL-TOKEN>
  values(select (prev-state)
           63 => 64;
           OTHERWISE => 57;
         end,
         begin
           list(rhs-1);
         end);
end method production-46;

define method production-47
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // container-option -> <EXCLUDE-FILE-TOKEN> <STRING-LITERAL-TOKEN>
  values(select (prev-state)
           137 => 138;
           OTHERWISE => 89;
         end,
         begin
           list(#"exclude-file", list(rhs-2));
         end);
end method production-47;

define method production-48
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // container-option -> <EXCLUDE-FILE-TOKEN> <LBRACE-TOKEN> exclude-list <RBRACE-TOKEN>
  values(select (prev-state)
           137 => 138;
           OTHERWISE => 89;
         end,
         begin
           list(#"exclude-file", rhs-3);
         end);
end method production-48;

define method production-49
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // container-option -> <RENAME-TOKEN> <LBRACE-TOKEN> renaming-list <RBRACE-TOKEN>
  values(select (prev-state)
           137 => 138;
           OTHERWISE => 89;
         end,
         begin
           list(#"rename", rhs-3);
         end);
end method production-49;

define method production-50
    (prev-state :: <integer>, srcloc-0 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // renaming-list -> epsilon
  values(select (prev-state)
           79 => 80;
           75 => 76;
           OTHERWISE => 70;
         end,
         begin
           #();
         end);
end method production-50;

define method production-51
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // renaming-list -> renaming-list <COMMA-TOKEN> renaming
  values(select (prev-state)
           79 => 80;
           75 => 76;
           OTHERWISE => 70;
         end,
         begin
           pair(rhs-3, rhs-1);
         end);
end method production-51;

define method production-52
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // renaming-list -> renaming
  values(select (prev-state)
           79 => 80;
           75 => 76;
           OTHERWISE => 70;
         end,
         begin
           list(rhs-1);
         end);
end method production-52;

define method production-53
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // container-option -> <MAPPING-TOKEN> <LBRACE-TOKEN> renaming-list <RBRACE-TOKEN>
  values(select (prev-state)
           137 => 138;
           OTHERWISE => 89;
         end,
         begin
           list(#"mapping", rhs-3);
         end);
end method production-53;

define method production-54
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // container-option -> <EQUATE-TOKEN> <LBRACE-TOKEN> renaming-list <RBRACE-TOKEN>
  values(select (prev-state)
           137 => 138;
           OTHERWISE => 89;
         end,
         begin
           list(#"equate", rhs-3);
         end);
end method production-54;

define method production-55
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // sealing -> <SEALED-TOKEN>
  values(select (prev-state)
           186 => 188;
           OTHERWISE => 86;
         end,
         begin
           rhs-1.string-value
         end);
end method production-55;

define method production-56
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // sealing -> <OPEN-TOKEN>
  values(select (prev-state)
           186 => 188;
           OTHERWISE => 86;
         end,
         begin
           rhs-1.string-value
         end);
end method production-56;

define method production-57
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // sealing -> <INLINE-TOKEN>
  values(select (prev-state)
           186 => 188;
           OTHERWISE => 86;
         end,
         begin
           parse-error(rhs-1, "'inline' not handled at present.")
         end);
end method production-57;

define method production-58
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // container-option -> <SEAL-FUNCTIONS-TOKEN> sealing
  values(select (prev-state)
           137 => 138;
           OTHERWISE => 89;
         end,
         begin
           list(#"seal", rhs-2);
         end);
end method production-58;

define method production-59
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <BOOLEAN-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // container-option -> <READ-ONLY-TOKEN> BOOLEAN
  values(select (prev-state)
           137 => 138;
           OTHERWISE => 89;
         end,
         begin
           list(#"read-only", rhs-2.value);
         end);
end method production-59;

define method production-60
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-clause -> <FUNCTION-TOKEN> <STRING-LITERAL-TOKEN> function-option-list
  values(select (prev-state)
           195 => 196;
           OTHERWISE => 193;
         end,
         begin
           srcloc-0.clauses := add!(srcloc-0.clauses,
                                  make(<function-clause>, 
                                       name: rhs-2.value, options: rhs-3));
         end);
end method production-60;

define method production-61
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4 :: <NAME-TOKEN>, srcloc-4 :: <source-location>,
     rhs-5, srcloc-5 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-clause -> <FUNCTION-TOKEN> <STRING-LITERAL-TOKEN> <ARROW-TOKEN> <IDENTIFIER-TOKEN> function-option-list
  values(select (prev-state)
           195 => 196;
           OTHERWISE => 193;
         end,
         begin
           srcloc-0.container-options.rename :=
              pair(pair(rhs-2.value, rhs-4.value), srcloc-0.container-options.rename);
           srcloc-0.clauses := add!(srcloc-0.clauses,
                                  make(<function-clause>,
                                       name: rhs-2.value, options: rhs-5));
         end);
end method production-61;

define method production-62
    (prev-state :: <integer>, srcloc-0 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // function-option-list -> epsilon
  values(select (prev-state)
           132 => 133;
           OTHERWISE => 101;
         end,
         begin
           #();
         end);
end method production-62;

define method production-63
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // function-option-list -> function-option-list <COMMA-TOKEN> function-option
  values(select (prev-state)
           132 => 133;
           OTHERWISE => 101;
         end,
         begin
           pair(rhs-3, rhs-1);
         end);
end method production-63;

define method production-64
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <NAME-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // function-option -> <MAP-RESULT-TOKEN> <IDENTIFIER-TOKEN>
  values(130,
         begin
           pair(#"map-result", rhs-2.string-value);
         end);
end method production-64;

define method production-65
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <NAME-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // function-option -> <EQUATE-RESULT-TOKEN> <IDENTIFIER-TOKEN>
  values(130,
         begin
           pair(#"equate-result", rhs-2.string-value);
         end);
end method production-65;

define method production-66
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <BOOLEAN-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // function-option -> <IGNORE-RESULT-TOKEN> BOOLEAN
  values(130,
         begin
           pair(#"ignore-result", rhs-2.value);
         end);
end method production-66;

define method production-67
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>,
     rhs-5 :: <NAME-TOKEN>, srcloc-5 :: <source-location>,
     rhs-6 :: <PUNCTUATION-TOKEN>, srcloc-6 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // function-option -> <MAP-ARGUMENT-TOKEN> <LBRACE-TOKEN> argument <ARROW-TOKEN> <IDENTIFIER-TOKEN> <RBRACE-TOKEN>
  values(130,
         begin
           pair(#"map-arg", pair(rhs-3.value, rhs-5.string-value));
         end);
end method production-67;

define method production-68
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>,
     rhs-5 :: <NAME-TOKEN>, srcloc-5 :: <source-location>,
     rhs-6 :: <PUNCTUATION-TOKEN>, srcloc-6 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // function-option -> <EQUATE-ARGUMENT-TOKEN> <LBRACE-TOKEN> argument <ARROW-TOKEN> <IDENTIFIER-TOKEN> <RBRACE-TOKEN>
  values(130,
         begin
           pair(#"equate-arg", pair(rhs-3.value, rhs-5.string-value));
         end);
end method production-68;

define method production-69
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // function-option -> <INPUT-ARGUMENT-TOKEN> argument
  values(130,
         begin
           pair(#"in", rhs-2.value);
         end);
end method production-69;

define method production-70
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // function-option -> <INPUT-OUTPUT-ARGUMENT-TOKEN> argument
  values(130,
         begin
           pair(#"in-out", rhs-2.value);
         end);
end method production-70;

define method production-71
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // function-option -> <OUTPUT-ARGUMENT-TOKEN> argument
  values(130,
         begin
           pair(#"out", rhs-2.value);
         end);
end method production-71;

define method production-72
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <LITERAL-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // argument -> <INTEGER-TOKEN>
  values(select (prev-state)
           128 => 129;
           126 => 127;
           124 => 125;
           119 => 120;
           OTHERWISE => 114;
         end,
         begin
           rhs-1;
         end);
end method production-72;

define method production-73
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <NAME-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // argument -> <IDENTIFIER-TOKEN>
  values(select (prev-state)
           128 => 129;
           126 => 127;
           124 => 125;
           119 => 120;
           OTHERWISE => 114;
         end,
         begin
           rhs-1;
         end);
end method production-73;

define method production-74
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <LITERAL-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // argument -> <STRING-LITERAL-TOKEN>
  values(select (prev-state)
           128 => 129;
           126 => 127;
           124 => 125;
           119 => 120;
           OTHERWISE => 114;
         end,
         begin
           rhs-1;
         end);
end method production-74;

define method production-75
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-clause -> <STRUCT-TOKEN> <STRING-LITERAL-TOKEN> structure-option-list
  values(select (prev-state)
           195 => 196;
           OTHERWISE => 193;
         end,
         begin
           let (container-opts, rest) = process-container-options(rhs-3);
           let new-clause = make(<struct-clause>, name: rhs-2.value, options: rest);
           new-clause.container-options := container-opts;
           srcloc-0.clauses := add!(srcloc-0.clauses, new-clause);
         end);
end method production-75;

define method production-76
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4 :: <NAME-TOKEN>, srcloc-4 :: <source-location>,
     rhs-5, srcloc-5 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-clause -> <STRUCT-TOKEN> <STRING-LITERAL-TOKEN> <ARROW-TOKEN> <IDENTIFIER-TOKEN> structure-option-list
  values(select (prev-state)
           195 => 196;
           OTHERWISE => 193;
         end,
         begin
           srcloc-0.container-options.rename :=
              pair(pair(rhs-2.value, rhs-4.value), srcloc-0.container-options.rename);
           let (container-opts, rest) = process-container-options(rhs-5);
           let new-clause = make(<struct-clause>, name: rhs-2.value, options: rest);
           new-clause.container-options := container-opts;
           srcloc-0.clauses := add!(srcloc-0.clauses, new-clause);
         end);
end method production-76;

define method production-77
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-clause -> <UNION-TOKEN> <STRING-LITERAL-TOKEN> structure-option-list
  values(select (prev-state)
           195 => 196;
           OTHERWISE => 193;
         end,
         begin
           let (container-opts, rest) = process-container-options(rhs-3);
           let new-clause = make(<union-clause>, name: rhs-2.value, options: rest);
           new-clause.container-options := container-opts;
           srcloc-0.clauses := add!(srcloc-0.clauses, new-clause);
         end);
end method production-77;

define method production-78
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4 :: <NAME-TOKEN>, srcloc-4 :: <source-location>,
     rhs-5, srcloc-5 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-clause -> <UNION-TOKEN> <STRING-LITERAL-TOKEN> <ARROW-TOKEN> <IDENTIFIER-TOKEN> structure-option-list
  values(select (prev-state)
           195 => 196;
           OTHERWISE => 193;
         end,
         begin
           srcloc-0.container-options.rename :=
              pair(pair(rhs-2.value, rhs-4.value), srcloc-0.container-options.rename);
           let (container-opts, rest) = process-container-options(rhs-5);
           let new-clause = make(<union-clause>, name: rhs-2.value, options: rest);
           new-clause.container-options := container-opts;
           srcloc-0.clauses := add!(srcloc-0.clauses, new-clause);
         end);
end method production-78;

define method production-79
    (prev-state :: <integer>, srcloc-0 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // structure-option-list -> epsilon
  values(select (prev-state)
           154 => 155;
           151 => 152;
           148 => 149;
           OTHERWISE => 136;
         end,
         begin
           #();
         end);
end method production-79;

define method production-80
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // structure-option-list -> structure-option-list <COMMA-TOKEN> container-option
  values(select (prev-state)
           154 => 155;
           151 => 152;
           148 => 149;
           OTHERWISE => 136;
         end,
         begin
           pair(rhs-3, rhs-1);
         end);
end method production-80;

define method production-81
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <NAME-TOKEN>, srcloc-1 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // superclass-list -> <IDENTIFIER-TOKEN>
  values(142,
         begin
           list(rhs-1.string-value);
         end);
end method production-81;

define method production-82
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <NAME-TOKEN>, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // superclass-list -> superclass-list <COMMA-TOKEN> <IDENTIFIER-TOKEN>
  values(142,
         begin
           pair(rhs-3.string-value, rhs-1);
         end);
end method production-82;

define method production-83
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>,
     rhs-4 :: <PUNCTUATION-TOKEN>, srcloc-4 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // superclass-option -> <SUPERCLASS-TOKEN> <LBRACE-TOKEN> superclass-list <RBRACE-TOKEN>
  values(select (prev-state)
           159 => 160;
           OTHERWISE => 146;
         end,
         begin
           pair(#"superclass", reverse!(rhs-3));
         end);
end method production-83;

define method production-84
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // structure-option-list -> structure-option-list <COMMA-TOKEN> superclass-option
  values(select (prev-state)
           154 => 155;
           151 => 152;
           148 => 149;
           OTHERWISE => 136;
         end,
         begin
           pair(rhs-3, rhs-1);
         end);
end method production-84;

define method production-85
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-clause -> <POINTER-TOKEN> <STRING-LITERAL-TOKEN> pointer-option-list
  values(select (prev-state)
           195 => 196;
           OTHERWISE => 193;
         end,
         begin
           let new-clause = make(<pointer-clause>, name: rhs-2.value, options: rhs-3);
           srcloc-0.clauses := add!(srcloc-0.clauses, new-clause);
         end);
end method production-85;

define method production-86
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4 :: <NAME-TOKEN>, srcloc-4 :: <source-location>,
     rhs-5, srcloc-5 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-clause -> <POINTER-TOKEN> <STRING-LITERAL-TOKEN> <ARROW-TOKEN> <IDENTIFIER-TOKEN> pointer-option-list
  values(select (prev-state)
           195 => 196;
           OTHERWISE => 193;
         end,
         begin
           srcloc-0.container-options.rename :=
              pair(pair(rhs-2.value, rhs-4.value), srcloc-0.container-options.rename);
           let new-clause = make(<pointer-clause>, name: rhs-2.value, options: rhs-5);
           srcloc-0.clauses := add!(srcloc-0.clauses, new-clause);
         end);
end method production-86;

define method production-87
    (prev-state :: <integer>, srcloc-0 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // pointer-option-list -> epsilon
  values(select (prev-state)
           162 => 163;
           OTHERWISE => 158;
         end,
         begin
           #();
         end);
end method production-87;

define method production-88
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // pointer-option-list -> pointer-option-list <COMMA-TOKEN> superclass-option
  values(select (prev-state)
           162 => 163;
           OTHERWISE => 158;
         end,
         begin
           pair(rhs-3, rhs-1);
         end);
end method production-88;

define method production-89
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-clause -> <CONSTANT-TOKEN> <STRING-LITERAL-TOKEN> constant-option-list
  values(select (prev-state)
           195 => 196;
           OTHERWISE => 193;
         end,
         begin
           srcloc-0.clauses := add!(srcloc-0.clauses,
                                  make(<constant-clause>, 
                                       name: rhs-2.value, options: rhs-3));
         end);
end method production-89;

define method production-90
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4 :: <NAME-TOKEN>, srcloc-4 :: <source-location>,
     rhs-5, srcloc-5 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-clause -> <CONSTANT-TOKEN> <STRING-LITERAL-TOKEN> <ARROW-TOKEN> <IDENTIFIER-TOKEN> constant-option-list
  values(select (prev-state)
           195 => 196;
           OTHERWISE => 193;
         end,
         begin
           srcloc-0.container-options.rename :=
              pair(pair(rhs-2.value, rhs-4.value), srcloc-0.container-options.rename);
           srcloc-0.clauses := add!(srcloc-0.clauses,
                                  make(<constant-clause>,
                                       name: rhs-2.value, options: rhs-5));
         end);
end method production-90;

define method production-91
    (prev-state :: <integer>, srcloc-0 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // constant-option-list -> epsilon
  values(select (prev-state)
           172 => 173;
           OTHERWISE => 166;
         end,
         begin
           #();
         end);
end method production-91;

define method production-92
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // constant-option-list -> constant-option-list <COMMA-TOKEN> constant-option
  values(select (prev-state)
           172 => 173;
           OTHERWISE => 166;
         end,
         begin
           pair(rhs-3, rhs-1);
         end);
end method production-92;

define method production-93
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // constant-option -> <VALUE-TOKEN> LITERAL
  values(170,
         begin
           pair(#"value", rhs-2.string-value);
         end);
end method production-93;

define method production-94
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-clause -> <VARIABLE-TOKEN> <STRING-LITERAL-TOKEN> variable-option-list
  values(select (prev-state)
           195 => 196;
           OTHERWISE => 193;
         end,
         begin
           srcloc-0.clauses := add!(srcloc-0.clauses,
                                  make(<variable-clause>, 
                                       name: rhs-2.value, options: rhs-3));
         end);
end method production-94;

define method production-95
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <LITERAL-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3 :: <PUNCTUATION-TOKEN>, srcloc-3 :: <source-location>,
     rhs-4 :: <NAME-TOKEN>, srcloc-4 :: <source-location>,
     rhs-5, srcloc-5 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // interface-clause -> <VARIABLE-TOKEN> <STRING-LITERAL-TOKEN> <ARROW-TOKEN> <IDENTIFIER-TOKEN> variable-option-list
  values(select (prev-state)
           195 => 196;
           OTHERWISE => 193;
         end,
         begin
           srcloc-0.container-options.rename :=
              pair(pair(rhs-2.value, rhs-4.value), srcloc-0.container-options.rename);
           srcloc-0.clauses := add!(srcloc-0.clauses,
                                  make(<variable-clause>,
                                       name: rhs-2.value, options: rhs-5));
         end);
end method production-95;

define method production-96
    (prev-state :: <integer>, srcloc-0 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // variable-option-list -> epsilon
  values(select (prev-state)
           191 => 192;
           OTHERWISE => 176;
         end,
         begin
           #();
         end);
end method production-96;

define method production-97
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1, srcloc-1 :: <source-location>,
     rhs-2 :: <PUNCTUATION-TOKEN>, srcloc-2 :: <source-location>,
     rhs-3, srcloc-3 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // variable-option-list -> variable-option-list <COMMA-TOKEN> variable-option
  values(select (prev-state)
           191 => 192;
           OTHERWISE => 176;
         end,
         begin
           pair(rhs-3, rhs-1);
         end);
end method production-97;

define method production-98
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <NAME-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // variable-option -> <GETTER-TOKEN> <IDENTIFIER-TOKEN>
  values(189,
         begin
           pair(#"getter", rhs-2.string-value);
         end);
end method production-98;

define method production-99
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <NAME-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // variable-option -> <SETTER-TOKEN> <IDENTIFIER-TOKEN>
  values(189,
         begin
           pair(#"setter", rhs-2.string-value);
         end);
end method production-99;

define method production-100
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <BOOLEAN-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // variable-option -> <READ-ONLY-TOKEN> BOOLEAN
  values(189,
         begin
           pair(#"read-only", rhs-2.value);
         end);
end method production-100;

define method production-101
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <NAME-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // variable-option -> <MAPPING-TOKEN> <IDENTIFIER-TOKEN>
  values(189,
         begin
           pair(#"map", rhs-2.string-value);
         end);
end method production-101;

define method production-102
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2 :: <NAME-TOKEN>, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // variable-option -> <EQUATE-TOKEN> <IDENTIFIER-TOKEN>
  values(189,
         begin
           pair(#"equate", rhs-2.string-value);
         end);
end method production-102;

define method production-103
    (prev-state :: <integer>, srcloc-0 :: <source-location>,
     rhs-1 :: <RESERVED-WORD-TOKEN>, srcloc-1 :: <source-location>,
     rhs-2, srcloc-2 :: <source-location>)
    => (new-state :: <integer>, new-symbol);
  // variable-option -> <GETTER-TOKEN> sealing
  values(189,
         begin
           pair(#"seal", rhs-2);
         end);
end method production-103;

define constant $number-of-pops
  = #[0, 2, 2, 5, 4, 2, 1, 3, 1, 1, 3, 5, 1, 3, 0, 3, 2, 2, 4, 4, 1, 1, 3, 1, 3, 3, 1, 3, 1, 2, 2, 2, 4, 4, 4, 6, 0, 3, 1, 1, 1, 3, 2, 4, 0, 3, 1, 2, 4, 4, 0, 3, 1, 4, 4, 1, 1, 1, 2, 2, 3, 5, 0, 3, 2, 2, 2, 6, 6, 2, 2, 2, 1, 1, 1, 3, 5, 3, 5, 0, 3, 1, 3, 4, 3, 3, 5, 0, 3, 3, 5, 0, 3, 2, 3, 5, 0, 3, 2, 2, 2, 2, 2, 2];

define constant $production-table :: <simple-object-vector>
  = vector(#f, production-1, production-2, production-3, production-4, production-5, production-6, production-7, production-8, production-9, production-10, production-11, production-12, production-13, production-14, production-15, production-16, production-17, production-18, production-19, production-20, production-21, production-22, production-23, production-24, production-25, production-26, production-27, production-28, production-29, production-30, production-31, production-32, production-33, production-34, production-35, production-36, production-37, production-38, production-39, production-40, production-41, production-42, production-43, production-44, production-45, production-46, production-47, production-48, production-49, production-50, production-51, production-52, production-53, production-54, production-55, production-56, production-57, production-58, production-59, production-60, production-61, production-62, production-63, production-64, production-65, production-66, production-67, production-68, production-69, production-70, production-71, production-72, production-73, production-74, production-75, production-76, production-77, production-78, production-79, production-80, production-81, production-82, production-83, production-84, production-85, production-86, production-87, production-88, production-89, production-90, production-91, production-92, production-93, production-94, production-95, production-96, production-97, production-98, production-99, production-100, production-101, production-102, production-103);

define constant $parse-root-start-state = 0;


//----------------------------------------------------------------------
// More parser boilerplate
//----------------------------------------------------------------------

// The initial size of the parser stacks.
// 
define constant $initial-stack-size = 200;

// grow -- internal.
//
// Grow a stack.  Make a new vector twice as long, copy the old elements
// across, and return it.
// 
define method grow (vec :: <simple-object-vector>)
    => new :: <simple-object-vector>;
  let old-size = vec.size;
  let new-size = old-size * 2;
  let new = make(<simple-object-vector>, size: new-size);
  for (index from 0 below old-size)
    new[index] := vec[index];
  end for;
  new;
end method grow;

define constant $eof-token = 0;

define method dformat (template :: <string>, #rest rest)
  apply(format, *standard-error*, template, rest);
  force-output(*standard-error*);
end method;

// parse -- internal.
//
// The actual parser loop.  Drive the state machine and maintain the stacks
// until we hit an accept action or until be hit a bogus token.
// 
define method parse-loop
    (parse-state :: <parse-state>, #key debug :: <boolean> = #f)
    => result :: <object>;
  let start-state = $parse-root-start-state;
  let tokenizer = parse-state.tokenizer;

  block (return)
    let state-stack = make(<simple-object-vector>, size: $initial-stack-size);
    let symbol-stack = make(<simple-object-vector>, size: $initial-stack-size);
    let srcloc-stack = make(<simple-object-vector>, size: $initial-stack-size);

    state-stack[0] := start-state;
    let top :: <integer> = 1;
    let (lookahead, lookahead-srcloc) = get-token(tokenizer);

    unless (lookahead.token-id == $eof-token)
      let actions :: <simple-object-vector> = $action-table[start-state];
      let action :: <integer> = actions[$eof-token];
    end unless;

    while (#t)
      let state :: <integer> = state-stack[top - 1];

      if (debug)
	dformat("top = %d, state = %d, lookahead = %s\n",
		top, state, lookahead.string-value);
      end if;

      let actions :: <simple-object-vector> = $action-table[state];
      let action :: <integer> = actions[lookahead.token-id];
      let (action-datum, action-kind)
	= truncate/(action, ash(1, $action-bits));
      select (action-kind)
	$error-action =>
	  parse-error(lookahead, "Parse error at or before %=",
		      lookahead.string-value);

	$accept-action =>
	  if (debug)
	    dformat("  accepting.\n");
	  end if;
	  unget-token(tokenizer, lookahead);
	  if (top ~== 2)
	    error("stack didn't get reduced all the way?");
	  end if;
	  return(symbol-stack[1]);

	$shift-action =>
	  if (top == state-stack.size)
	    state-stack := grow(state-stack);
	    symbol-stack := grow(symbol-stack);
	    srcloc-stack := grow(srcloc-stack);
	  end if;
	  if (debug)
	    dformat("  shifting to state %d.\n", action-datum);
	  end if;
	  state-stack[top] := action-datum;
	  symbol-stack[top] := lookahead;
	  srcloc-stack[top] := lookahead-srcloc;
	  top := top + 1;
	  let (new-lookahead, new-srcloc) = get-token(tokenizer);
	  lookahead := new-lookahead;
	  lookahead-srcloc := new-srcloc;

	  unless (lookahead.token-id == $eof-token)
	    let actions :: <simple-object-vector>
	      = $action-table[action-datum];
	    let action :: <integer> = actions[$eof-token];
	  end unless;

	$reduce-action =>
	  let semantic-action :: <function>
	    = $production-table[action-datum];
	  let number-pops :: <integer>
	    = $number-of-pops[action-datum];
	  if (debug)
	    dformat("  reducing by production %d, num pops = %d\n",
		    action-datum, number-pops);
	  end if;
	  let old-top = top - number-pops;
	  let extra-args = make(<simple-object-vector>, size: number-pops * 2);
	  for (index from 0 below number-pops)
	    extra-args[index * 2] := symbol-stack[old-top + index];
	    extra-args[index * 2 + 1] := srcloc-stack[old-top + index];
	  end for;
	  let new-srcloc = parse-state;
	  let (new-state :: <integer>, new-symbol)
	    = apply(semantic-action, state-stack[old-top - 1], new-srcloc,
		    extra-args);
	  if (old-top == state-stack.size)
	    state-stack := grow(state-stack);
	    symbol-stack := grow(symbol-stack);
	    srcloc-stack := grow(srcloc-stack);
	  end if;
	  state-stack[old-top] := new-state;
	  symbol-stack[old-top] := new-symbol;
	  srcloc-stack[old-top] := new-srcloc;
	  top := old-top + 1;
	  // Unlike most parsers, we don't care if we've hit EOF.  This
	  // doesn't sit well with the parser generator, so we cheat by faking
	  // an accepting state.
	  if (top == 2) return(symbol-stack[1]) end if;
      end select;
    end while;
  end block;
end method parse-loop;


//----------------------------------------------------------------------
// External interfaces to the parsing engine.
//----------------------------------------------------------------------

// This function processes a single "define interface" form, using the
// tokenizer in "parse-state", and annotates the parse state with the
// information acquired.
//
define method parse (parse-state :: <parse-state>)
  parse-loop(parse-state);
end;
